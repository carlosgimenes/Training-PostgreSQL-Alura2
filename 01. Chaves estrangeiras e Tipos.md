# Alura - PostgreSQL: Views, Sub-Consultas e Fun√ß√µes

## Neste Cap√≠tulo

- [Introdu√ß√£o](#introdu√ß√£o)
- [Projeto inicial do treinamento](#projeto-inicial-do-treinamento)
- [Introdu√ß√£o ao Banco de Dados](#introdu√ß√£o-ao-banco-de-dados)
  - [Explorando o PostgreSQL no pgAdmin](#explorando-o-postgresql-no-pgadmin)
  - [O que √© uma chave prim√°ria?](#o-que-√©-uma-chave-prim√°ria)
  - [Criando Identificadores na Tabela](#criando-identificadores-na-tabela)
  - [Relacionamento Entre Tabelas](#relacionamento-entre-tabelas)
- [Chaves Estrangeiras](#chaves-estrangeiras)
  - [Entendendo as Chaves Estrangeiras](#entendendo-as-chaves-estrangeiras)
  - [Evoluindo o Banco de Dados](#evoluindo-o-banco-de-dados)
  - [Solu√ß√£o: Criar uma Tabela de Categorias](#solu√ß√£o-criar-uma-tabela-de-categorias)
  - [Atualizando o Banco de Dados](#atualizando-o-banco-de-dados)
  - [Desafio](#desafio)
  - [Testando conhecimento adquirido - Defini√ß√£o formal](#testando-conhecimento-adquirido---defini√ß√£o-formal)

---

## **Introdu√ß√£o**

Nesta etapa, revisaremos conceitos essenciais, como **chaves prim√°rias, chaves estrangeiras e a cl√°usula UNIQUE**, explorando como ela pode ser utilizada por chaves estrangeiras. Tamb√©m veremos **diferen√ßas de sintaxe**, principalmente nas chaves estrangeiras, al√©m de um **exemplo pr√°tico de chave prim√°ria composta**.  

A partir desses estudos, avan√ßaremos at√© aprender **novas formas de inser√ß√£o de dados**, incluindo como **preencher m√∫ltiplas linhas com uma √∫nica instru√ß√£o** e como **inserir valores sem precisar informar os nomes dos campos**. Todo esse conhecimento nos preparar√° para **cria√ß√£o de relat√≥rios**, que ser√£o desenvolvidos passo a passo, permitindo que voc√™ acompanhe todo o processo real de gera√ß√£o de relat√≥rios.  

Durante esse avan√ßo, exploraremos **novos operadores, como o IN**, al√©m de aprender como **realizar consultas dentro de outras consultas**, dando nome a essas consultas para facilitar sua interpreta√ß√£o.  

Al√©m disso, vamos mergulhar em fun√ß√µes do Postgres para manipula√ß√£o de **strings, datas, n√∫meros, convers√µes de formatos e muito mais**.  

---

## **Projeto inicial do treinamento**

Aqui s√£o fornecidos os arquivos para o projeto inicial deste treinamento, necess√°rio para a continuidade do mesmo.

- [banco-inicial.sql](./src/banco-inicial.sql)

---

## **Introdu√ß√£o ao Banco de Dados**  

Vamos come√ßar com uma r√°pida revis√£o do que aprendemos no curso anterior. Primeiro, compreendemos o que √© um banco de dados: um espa√ßo onde armazenamos informa√ß√µes bem definidas. No caso de um banco de dados relacional, como o PostgreSQL, ele funciona de maneira semelhante a uma planilha.  

Em uma planilha, temos colunas que definem os tipos de informa√ß√µes a serem inseridas e linhas que representam os dados individuais, como no exemplo:  

| primeiro_nome | ultimo_nome | data_nascimento |
|--------------|------------|----------------|
| Vinicius    | Dias       | 1997-10-15     |
| Maria       | Rosa       | 1997-01-01     |

Cada linha representa um **registro** de informa√ß√µes. O banco de dados relacional segue esse mesmo princ√≠pio, mas com uma diferen√ßa fundamental: ele n√£o se limita a uma √∫nica tabela. Em vez disso, pode conter m√∫ltiplas tabelas, como diferentes planilhas dentro de um mesmo arquivo.  

Por exemplo, se tivermos uma aba chamada "P√°gina 2" em nossa planilha, encontraremos outra tabela com informa√ß√µes diferentes, como os cursos cadastrados:  

| nome |
|------|
| HTML |
| JS   |
| CSS  |

Assim, de forma simplificada, √© organizado um banco de dados.  

### **Explorando o PostgreSQL no pgAdmin**  

Ao acessar o **pgAdmin**, vemos que o servidor gerenciado pelo PostgreSQL cont√©m um banco de dados chamado **"alura"**. Esse banco funciona como um arquivo de planilha, e dentro dele h√° uma tabela chamada **"aluno"**, que cont√©m um campo **"id"**, nossa chave prim√°ria.  

#### **O que √© uma chave prim√°ria?**  

A chave prim√°ria √© um identificador √∫nico para os registros de uma tabela. Com ela, o banco de dados pode diferenciar um aluno espec√≠fico dos demais.  

Al√©m do campo **"id"**, a tabela **"aluno"** possui outros atributos:  

- **"primeiro_nome"** ‚Äì tipo **VARCHAR**, representando um texto que n√£o pode ser nulo (**NOT NULL**)  
- **"ultimo_nome"** ‚Äì tamb√©m **VARCHAR** e **NOT NULL**  
- **"data_nascimento"** ‚Äì tipo **DATE**, que obviamente n√£o pode ser nulo  

J√° a tabela **"curso"** funciona como outra aba do mesmo arquivo de planilha. Ela cont√©m:  

- **"id"** ‚Äì identificador √∫nico para cada curso (**PRIMARY KEY**)  
- **"nome"** ‚Äì nome do curso, que tamb√©m deve ser preenchido (**NOT NULL**)  

Vale destacar que **todo campo definido como chave prim√°ria j√° √© automaticamente NOT NULL**, ou seja, ele n√£o pode conter valores nulos.

#### **Criando Identificadores na Tabela**  

Podemos definir a chave prim√°ria de diferentes formas. No caso do **id**, utilizamos **SERIAL PRIMARY KEY**, onde **SERIAL** faz com que os n√∫meros sejam automaticamente incrementados. Outra possibilidade seria usar **CPF CHAR(11) PRIMARY KEY**. Nesse caso, ao inv√©s de o banco gerar automaticamente um identificador, precisar√≠amos informar manualmente cada CPF, mas a estrutura seguiria funcionando normalmente.  

### **Relacionamento Entre Tabelas**  

Depois de definir as tabelas **"aluno"** e **"curso"**, criamos uma **tabela de relacionamento**. Essa tabela indica que um aluno est√° matriculado em um curso.  

- Um curso pode ter **v√°rios alunos**  
- Um aluno pode estar **matriculado em v√°rios cursos**  

Para garantir que um mesmo aluno **n√£o seja cadastrado duas vezes no mesmo curso**, utilizamos uma **chave prim√°ria composta**. Isso significa que o identificador √∫nico desse relacionamento √© a combina√ß√£o de duas colunas: o ID do aluno e o ID do curso.  

Dessa forma, **n√£o podemos repetir a matr√≠cula do mesmo aluno para o mesmo curso**. Assim, as duas colunas formam um identificador √∫nico, garantindo integridade nos dados.  

Agora que revisamos esses conceitos, **vamos incrementar nosso banco de dados!**  

---

## **Chaves Estrangeiras**  

Vamos revisar o conceito de **chaves estrangeiras**, refor√ßando pontos importantes e explorando novas aplica√ß√µes.  

### **Entendendo as Chaves Estrangeiras**  

Uma chave estrangeira estabelece **um v√≠nculo entre tabelas**, garantindo a **integridade dos dados** ao impedir que registros sejam inseridos sem uma refer√™ncia v√°lida.  

Por exemplo, a tabela **"aluno_curso"** √© respons√°vel por armazenar a rela√ß√£o entre alunos e cursos. Sempre que um novo aluno for matriculado, precisamos garantir que ele **j√° exista na tabela "aluno"**, e o mesmo vale para os cursos cadastrados.  

No treinamento anterior, aprendemos a definir chaves estrangeiras de duas formas:  

1. **Usando a sintaxe expl√≠cita**

   ```sql
   FOREIGN KEY (nome_do_campo) REFERENCES nome_da_tabela(nome_do_campo_na_tabela)
   ```  

   Isso cria uma restri√ß√£o para assegurar que o valor inserido em um campo seja v√°lido dentro da tabela referenciada.  

2. **Definindo diretamente na cria√ß√£o do campo**  

   ```sql
   aluno_id INTEGER NOT NULL REFERENCES aluno(id)
   ```  

   Aqui, garantimos que **"aluno_id"** ser√° um n√∫mero inteiro **n√£o nulo** e que **deve existir na tabela "aluno"**, referenciando seu campo "id".  

Com essa configura√ß√£o, **n√£o conseguimos inserir um aluno_id que n√£o exista previamente na tabela "aluno"**, garantindo a consist√™ncia dos dados. O mesmo princ√≠pio se aplica ao **curso_id**, que deve referenciar um curso v√°lido.  

---

### **Evoluindo o Banco de Dados**  

Agora, precisamos organizar nossos cursos em **categorias**. A primeira ideia seria adicionar um campo `categoria VARCHAR(255) NOT NULL` √† tabela "curso". Isso nos permitiria definir manualmente a categoria de cada curso.  

Entretanto, essa abordagem pode causar problemas, como:  

- **Consumo desnecess√°rio de espa√ßo**, j√° que o mesmo nome de categoria pode se repetir v√°rias vezes.  
- **Inconsist√™ncia nos dados**, devido a varia√ß√µes na digita√ß√£o, como "Front-End", "front end", "programa√ßao", "programac√£o", etc.  

### **Solu√ß√£o: Criar uma Tabela de Categorias**  

Para evitar inconsist√™ncias, vamos criar uma tabela separada para armazenar as categorias:  

```sql
CREATE TABLE categoria (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(255) NOT NULL
);
```  

Aqui, **cada categoria ser√° identificada por um ID √∫nico**. Dessa forma, em vez de repetir o nome da categoria na tabela "curso", apenas referenciamos o ID correspondente.  

Agora podemos relacionar a tabela **"categoria"** com **"curso"**, garantindo que cada curso perten√ßa a uma categoria v√°lida:  

```sql
CREATE TABLE curso (
    id SERIAL PRIMARY KEY, 
    nome VARCHAR(255) NOT NULL, 
    categoria_id INTEGER NOT NULL REFERENCES categoria(id)
);
```  

Com essa abordagem:  

‚úÖ **Reduzimos o espa√ßo ocupado** (substituindo texto por um identificador num√©rico).  
‚úÖ **Evitamos erros de digita√ß√£o** ao utilizar chaves estrangeiras.  
‚úÖ **Mantemos a estrutura do banco de dados mais organizada e eficiente**.  

### **Atualizando o Banco de Dados**  

Para implementar essa melhoria, **precisamos excluir a tabela "curso" existente** e recri√°-la com a chave estrangeira `categoria_id`.  

Entretanto, o banco de dados impede a exclus√£o da tabela "curso" porque **outras tabelas dependem dela** como "aluno_curso".  

Para resolver esse impasse, **primeiro exclu√≠mos "aluno_curso", depois "curso"**:  

```sql
DROP TABLE aluno_curso, curso;
```  

Agora podemos recriar a tabela "curso" com a nova estrutura e estabelecer a chave estrangeira corretamente.  

---

### **Desafio**  

Agora que configuramos nossa tabela de categorias, o desafio √© **popular o banco de dados** com:  

- **Alunos**  
- **Categorias**  
- **Cursos**  
- **Matr√≠culas dos alunos nos cursos**  

Al√©m disso, podemos reorganizar o c√≥digo SQL movendo a cria√ß√£o da tabela **"categoria"** para antes da tabela "curso", pois **um curso precisa de uma categoria antes de ser criado**.  

Na pr√≥xima etapa do treinamento, vamos aprofundar nosso entendimento sobre **tipos de relacionamentos**.  

---

### **Resolu√ß√£o do Desafio**

Para realiza√ß√£o do desafio, criei e executei o script abaixo:

- [populando-banco-dados.sql](./src/populando-banco-dados.sql)

---

### **Testando conhecimento adquirido - Defini√ß√£o formal**

Revisamos o conceito de chaves estrangeiras, inclusive aplicando em um cen√°rio diferente.

Qual das alternativas a seguir pode ser utilizada como defini√ß√£o de _**chave estrangeira?**_

![Defini√ß√£o chave estrangeira](./images/RevisaoConceitos-ChaveEstrangeira.png)

---

## **Tipos de Relacionamentos em Banco de Dados**  

J√° exploramos **chaves prim√°rias** e **chaves estrangeiras**, mas h√° um detalhe importante: **sempre que criamos uma chave estrangeira, ela deve referenciar um campo √∫nico**.  

Por exemplo, se tent√°ssemos referenciar o campo `"nome"` da tabela `"categoria"` como chave estrangeira, isso n√£o funcionaria. Afinal, nossa tabela pode conter **m√∫ltiplos registros com o mesmo nome de categoria**, como `"Programa√ß√£o"`, o que tornaria a refer√™ncia inv√°lida.  

Entretanto, se **modificarmos esse campo** para `nome VARCHAR(255) NOT NULL UNIQUE`, garantindo que cada nome seja √∫nico, poder√≠amos referenci√°-lo como uma chave estrangeira.  

Apesar dessa possibilidade, a pr√°tica mais comum (e recomendada) √© que chaves estrangeiras **referenciem chaves prim√°rias**. Isso garante que a refer√™ncia seja a um **identificador √∫nico**, ou seja, um dado que o banco j√° trata como um identificador exclusivo daquela tabela.

---

### **O que √© Cardinalidade?**  

Quando falamos de **tipos de relacionamentos**, estamos tratando de um conceito chamado **cardinalidade**. Esse estudo analisa como as tabelas se relacionam entre si e define **quantos registros de uma tabela podem se associar a outra**.  

Vamos analisar alguns casos pr√°ticos.

---

### **Relacionamento 1:N (Um para Muitos) e N:1 (Muitos para Um)**  

A tabela `"categoria"` e a tabela `"curso"` possuem um **relacionamento 1:N**. Isso significa que:  

- **Uma categoria pode estar associada a muitos cursos**  
- **Cada curso pertence a apenas uma categoria**  

Ou seja, um √∫nico registro na tabela `"categoria"` pode estar presente em **diversos cursos**, mas cada curso pode ter **apenas uma categoria**. Esse tipo de relacionamento **n√£o exige uma tabela auxiliar**, pois pode ser estabelecido diretamente entre as tabelas principais usando uma chave estrangeira.

---

### **Relacionamento N:N (Muitos para Muitos)**  

No caso de **alunos e cursos**, o relacionamento √© **N:N (muitos para muitos)**. Isso significa que:  

- **Um mesmo aluno pode se matricular em v√°rios cursos**  
- **Um mesmo curso pode ter v√°rios alunos**  

Sempre que um relacionamento for **muitos para muitos**, √© necess√°rio **criar uma tabela de jun√ß√£o** nesse caso, a tabela `"aluno_curso"`.  

Essa tabela **n√£o representa uma entidade isolada**, mas sim **a rela√ß√£o entre cursos e alunos**.

---

### **Relacionamento 1:1 (Um para Um)**  

Esse √© um tipo de relacionamento **menos comum**, mas √∫til para a organiza√ß√£o do banco de dados.  

Por exemplo, suponha que cada aluno tenha um **√∫nico endere√ßo**. Podemos armazenar as informa√ß√µes de endere√ßo diretamente na tabela `"aluno"`, adicionando campos como `"rua"`, `"bairro"`, `"cidade"` e `"n√∫mero"`.  

Alternativamente, podemos criar uma **tabela separada** chamada `"endereco"`, contendo:  

| id  | rua       | bairro    | cidade  | estado | cep        | n√∫mero |
|----|----------|----------|--------|--------|----------|--------|
| 1  | Rua X     | Centro    | SP      | SP     | 01000-000 | 100    |

Em `"aluno"`, ter√≠amos apenas um campo **"endereco_id"** que referencia essa tabela. Como cada aluno tem **apenas um endere√ßo**, e cada endere√ßo pertence a **apenas um aluno**, esse seria um exemplo de **relacionamento 1:1**.  

O **relacionamento 1:1 √© √∫til quando temos informa√ß√µes extensas** que podem ser organizadas de forma mais eficiente ao separ√°-las em tabelas diferentes.

---

### **Resumo dos Tipos de Relacionamento**  

| Tipo de Relacionamento | Exemplo |
|----------------|---------|
| **1:N** (um para muitos) | Categoria ‚Üí Curso |
| **N:N** (muitos para muitos) | Aluno ‚Üî Curso (necess√°rio tabela de jun√ß√£o) |
| **1:1** (um para um) | Aluno ‚Üî Endere√ßo |

Essa compreens√£o nos permite estruturar um banco de dados de forma **mais eficiente e organizada**.  

---

### **Integridade Referencial**

A **integridade referencial** √© um dos pilares essenciais na modelagem de bancos de dados relacionais. Ao garantir que as chaves estrangeiras sempre referenciem registros v√°lidos em tabelas relacionadas, evitamos erros e inconsist√™ncias nos dados. Aqui est√£o os principais benef√≠cios:

üîπ **Consist√™ncia dos dados** ‚Äì Impede que registros fiquem √≥rf√£os, ou seja, evita que uma tabela fa√ßa refer√™ncia a dados que n√£o existem mais na tabela principal.

üîπ **Preven√ß√£o de erros** ‚Äì Se um aluno est√° matriculado em um curso, mas esse curso for exclu√≠do sem um controle de integridade, o banco de dados poderia ficar inconsistente. Com a integridade referencial, esse tipo de erro √© evitado.

üîπ **Facilidade na manuten√ß√£o** ‚Äì Garante que altera√ß√µes nos dados sejam feitas de maneira segura. Por exemplo, se um curso precisa ser atualizado, todas as tabelas relacionadas continuar√£o corretas sem impactos negativos.

üîπ **Otimiza√ß√£o das consultas** ‚Äì Um banco de dados bem estruturado e consistente permite consultas mais r√°pidas e eficientes, j√° que a l√≥gica de relacionamento entre os dados est√° clara e bem definida.

üîπ **Evita duplica√ß√£o de dados** ‚Äì Como as tabelas est√£o corretamente relacionadas, reduz-se a necessidade de armazenar informa√ß√µes repetidas, contribuindo para uma estrutura mais enxuta e organizada.

üîπ **Melhora a integridade transacional** ‚Äì Em opera√ß√µes que envolvem m√∫ltiplas tabelas, a integridade referencial garante que todas as partes de uma transa√ß√£o sejam conclu√≠das corretamente, evitando problemas com informa√ß√µes incompletas.

Esses benef√≠cios tornam a integridade referencial uma pr√°tica fundamental em qualquer banco de dados relacional. No seu treinamento, ao configurar corretamente os relacionamentos, voc√™ estar√° garantindo um sistema mais seguro, confi√°vel e eficiente!

No pr√≥ximo cap√≠tulo, vamos colocar em pr√°tica tudo o que aprendemos: **manipular bancos de dados, criar relat√≥rios e muito mais!** üöÄ  

---
