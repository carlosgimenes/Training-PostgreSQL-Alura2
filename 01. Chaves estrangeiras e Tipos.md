# Alura - PostgreSQL: Views, Sub-Consultas e Funções

## Neste Capítulo

- [Introdução](#introdução)
- [Projeto inicial do treinamento](#projeto-inicial-do-treinamento)
- [Introdução ao Banco de Dados](#introdução-ao-banco-de-dados)
  - [Explorando o PostgreSQL no pgAdmin](#explorando-o-postgresql-no-pgadmin)
  - [O que é uma chave primária?](#o-que-é-uma-chave-primária)
  - [Criando Identificadores na Tabela](#criando-identificadores-na-tabela)
  - [Relacionamento Entre Tabelas](#relacionamento-entre-tabelas)
- [Chaves Estrangeiras](#chaves-estrangeiras)
  - [Entendendo as Chaves Estrangeiras](#entendendo-as-chaves-estrangeiras)
  - [Evoluindo o Banco de Dados](#evoluindo-o-banco-de-dados)
  - [Solução: Criar uma Tabela de Categorias](#solução-criar-uma-tabela-de-categorias)
  - [Atualizando o Banco de Dados](#atualizando-o-banco-de-dados)
  - [Desafio](#desafio)

---

## **Introdução**

Nesta etapa, revisaremos conceitos essenciais, como **chaves primárias, chaves estrangeiras e a cláusula UNIQUE**, explorando como ela pode ser utilizada por chaves estrangeiras. Também veremos **diferenças de sintaxe**, principalmente nas chaves estrangeiras, além de um **exemplo prático de chave primária composta**.  

A partir desses estudos, avançaremos até aprender **novas formas de inserção de dados**, incluindo como **preencher múltiplas linhas com uma única instrução** e como **inserir valores sem precisar informar os nomes dos campos**. Todo esse conhecimento nos preparará para **criação de relatórios**, que serão desenvolvidos passo a passo, permitindo que você acompanhe todo o processo real de geração de relatórios.  

Durante esse avanço, exploraremos **novos operadores, como o IN**, além de aprender como **realizar consultas dentro de outras consultas**, dando nome a essas consultas para facilitar sua interpretação.  

Além disso, vamos mergulhar em funções do Postgres para manipulação de **strings, datas, números, conversões de formatos e muito mais**.  

---

## **Projeto inicial do treinamento**

Aqui são fornecidos os arquivos para o projeto inicial deste treinamento, necessário para a continuidade do mesmo.

- [banco-inicial.sql](./src/banco-inicial.sql)

---

## **Introdução ao Banco de Dados**  

Vamos começar com uma rápida revisão do que aprendemos no curso anterior. Primeiro, compreendemos o que é um banco de dados: um espaço onde armazenamos informações bem definidas. No caso de um banco de dados relacional, como o PostgreSQL, ele funciona de maneira semelhante a uma planilha.  

Em uma planilha, temos colunas que definem os tipos de informações a serem inseridas e linhas que representam os dados individuais, como no exemplo:  

| primeiro_nome | ultimo_nome | data_nascimento |
|--------------|------------|----------------|
| Vinicius    | Dias       | 1997-10-15     |
| Maria       | Rosa       | 1997-01-01     |

Cada linha representa um **registro** de informações. O banco de dados relacional segue esse mesmo princípio, mas com uma diferença fundamental: ele não se limita a uma única tabela. Em vez disso, pode conter múltiplas tabelas, como diferentes planilhas dentro de um mesmo arquivo.  

Por exemplo, se tivermos uma aba chamada "Página 2" em nossa planilha, encontraremos outra tabela com informações diferentes, como os cursos cadastrados:  

| nome |
|------|
| HTML |
| JS   |
| CSS  |

Assim, de forma simplificada, é organizado um banco de dados.  

### **Explorando o PostgreSQL no pgAdmin**  

Ao acessar o **pgAdmin**, vemos que o servidor gerenciado pelo PostgreSQL contém um banco de dados chamado **"alura"**. Esse banco funciona como um arquivo de planilha, e dentro dele há uma tabela chamada **"aluno"**, que contém um campo **"id"**, nossa chave primária.  

#### **O que é uma chave primária?**  

A chave primária é um identificador único para os registros de uma tabela. Com ela, o banco de dados pode diferenciar um aluno específico dos demais.  

Além do campo **"id"**, a tabela **"aluno"** possui outros atributos:  

- **"primeiro_nome"** – tipo **VARCHAR**, representando um texto que não pode ser nulo (**NOT NULL**)  
- **"ultimo_nome"** – também **VARCHAR** e **NOT NULL**  
- **"data_nascimento"** – tipo **DATE**, que obviamente não pode ser nulo  

Já a tabela **"curso"** funciona como outra aba do mesmo arquivo de planilha. Ela contém:  

- **"id"** – identificador único para cada curso (**PRIMARY KEY**)  
- **"nome"** – nome do curso, que também deve ser preenchido (**NOT NULL**)  

Vale destacar que **todo campo definido como chave primária já é automaticamente NOT NULL**, ou seja, ele não pode conter valores nulos.

#### **Criando Identificadores na Tabela**  

Podemos definir a chave primária de diferentes formas. No caso do **id**, utilizamos **SERIAL PRIMARY KEY**, onde **SERIAL** faz com que os números sejam automaticamente incrementados. Outra possibilidade seria usar **CPF CHAR(11) PRIMARY KEY**. Nesse caso, ao invés de o banco gerar automaticamente um identificador, precisaríamos informar manualmente cada CPF, mas a estrutura seguiria funcionando normalmente.  

### **Relacionamento Entre Tabelas**  

Depois de definir as tabelas **"aluno"** e **"curso"**, criamos uma **tabela de relacionamento**. Essa tabela indica que um aluno está matriculado em um curso.  

- Um curso pode ter **vários alunos**  
- Um aluno pode estar **matriculado em vários cursos**  

Para garantir que um mesmo aluno **não seja cadastrado duas vezes no mesmo curso**, utilizamos uma **chave primária composta**. Isso significa que o identificador único desse relacionamento é a combinação de duas colunas: o ID do aluno e o ID do curso.  

Dessa forma, **não podemos repetir a matrícula do mesmo aluno para o mesmo curso**. Assim, as duas colunas formam um identificador único, garantindo integridade nos dados.  

Agora que revisamos esses conceitos, **vamos incrementar nosso banco de dados!**  

---

## **Chaves Estrangeiras**  

Vamos revisar o conceito de **chaves estrangeiras**, reforçando pontos importantes e explorando novas aplicações.  

### **Entendendo as Chaves Estrangeiras**  

Uma chave estrangeira estabelece **um vínculo entre tabelas**, garantindo a **integridade dos dados** ao impedir que registros sejam inseridos sem uma referência válida.  

Por exemplo, a tabela **"aluno_curso"** é responsável por armazenar a relação entre alunos e cursos. Sempre que um novo aluno for matriculado, precisamos garantir que ele **já exista na tabela "aluno"**, e o mesmo vale para os cursos cadastrados.  

No treinamento anterior, aprendemos a definir chaves estrangeiras de duas formas:  

1. **Usando a sintaxe explícita**

   ```sql
   FOREIGN KEY (nome_do_campo) REFERENCES nome_da_tabela(nome_do_campo_na_tabela)
   ```  

   Isso cria uma restrição para assegurar que o valor inserido em um campo seja válido dentro da tabela referenciada.  

2. **Definindo diretamente na criação do campo**  

   ```sql
   aluno_id INTEGER NOT NULL REFERENCES aluno(id)
   ```  

   Aqui, garantimos que **"aluno_id"** será um número inteiro **não nulo** e que **deve existir na tabela "aluno"**, referenciando seu campo "id".  

Com essa configuração, **não conseguimos inserir um aluno_id que não exista previamente na tabela "aluno"**, garantindo a consistência dos dados. O mesmo princípio se aplica ao **curso_id**, que deve referenciar um curso válido.  

---

### **Evoluindo o Banco de Dados**  

Agora, precisamos organizar nossos cursos em **categorias**. A primeira ideia seria adicionar um campo `categoria VARCHAR(255) NOT NULL` à tabela "curso". Isso nos permitiria definir manualmente a categoria de cada curso.  

Entretanto, essa abordagem pode causar problemas, como:  

- **Consumo desnecessário de espaço**, já que o mesmo nome de categoria pode se repetir várias vezes.  
- **Inconsistência nos dados**, devido a variações na digitação, como "Front-End", "front end", "programaçao", "programacão", etc.  

### **Solução: Criar uma Tabela de Categorias**  

Para evitar inconsistências, vamos criar uma tabela separada para armazenar as categorias:  

```sql
CREATE TABLE categoria (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(255) NOT NULL
);
```  

Aqui, **cada categoria será identificada por um ID único**. Dessa forma, em vez de repetir o nome da categoria na tabela "curso", apenas referenciamos o ID correspondente.  

Agora podemos relacionar a tabela **"categoria"** com **"curso"**, garantindo que cada curso pertença a uma categoria válida:  

```sql
CREATE TABLE curso (
    id SERIAL PRIMARY KEY, 
    nome VARCHAR(255) NOT NULL, 
    categoria_id INTEGER NOT NULL REFERENCES categoria(id)
);
```  

Com essa abordagem:  

✅ **Reduzimos o espaço ocupado** (substituindo texto por um identificador numérico).  
✅ **Evitamos erros de digitação** ao utilizar chaves estrangeiras.  
✅ **Mantemos a estrutura do banco de dados mais organizada e eficiente**.  

### **Atualizando o Banco de Dados**  

Para implementar essa melhoria, **precisamos excluir a tabela "curso" existente** e recriá-la com a chave estrangeira `categoria_id`.  

Entretanto, o banco de dados impede a exclusão da tabela "curso" porque **outras tabelas dependem dela** como "aluno_curso".  

Para resolver esse impasse, **primeiro excluímos "aluno_curso", depois "curso"**:  

```sql
DROP TABLE aluno_curso, curso;
```  

Agora podemos recriar a tabela "curso" com a nova estrutura e estabelecer a chave estrangeira corretamente.  

---

### **Desafio**  

Agora que configuramos nossa tabela de categorias, o desafio é **popular o banco de dados** com:  

- **Alunos**  
- **Categorias**  
- **Cursos**  
- **Matrículas dos alunos nos cursos**  

Além disso, podemos reorganizar o código SQL movendo a criação da tabela **"categoria"** para antes da tabela "curso", pois **um curso precisa de uma categoria antes de ser criado**.  

Na próxima etapa do treinamento, vamos aprofundar nosso entendimento sobre **tipos de relacionamentos**.  

---

### **Resolução do Desafio**

Para realização do desafio, criei e executei o script abaixo:

- [populando-banco-dados.sql](./src/populando-banco-dados.sql)

---

Testando conhecimento adquirido - Definição formal

Revisamos o conceito de chaves estrangeiras, inclusive aplicando em um cenário diferente.

Qual das alternativas a seguir pode ser utilizada como definição de _**chave estrangeira?**_

![Definição chave estrangeira](./images/RevisaoConceitos-ChaveEstrangeira.png)

---
